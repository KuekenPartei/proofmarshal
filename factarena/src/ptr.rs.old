use core::alloc::Layout;
use core::borrow::Borrow;
use core::fmt;
use core::ptr::NonNull;
use core::ops;

pub trait Metadata {
    /// Metadata about this type.
    type Metadata : Copy + fmt::Debug;
}

/// The target of a pointer.
pub trait Type : Metadata {
    /// The owned form of this type.
    type Owned : Borrow<Self>;

    /// Makes a pointer to value of this type.
    fn make_fat_ptr(thin: *const (), metadata: Self::Metadata) -> *const Self;

    /// Makes a mutable pointer to a value of this type.
    fn make_fat_ptr_mut(thin: *mut (), metadata: Self::Metadata) -> *mut Self;

    /// Makes a `NonNull` to a value of this type.
    #[inline(always)]
    fn make_fat_non_null(thin: NonNull<()>, metadata: Self::Metadata) -> NonNull<Self> {
        let p: *mut Self = Self::make_fat_ptr_mut(thin.as_ptr(), metadata);
        unsafe {
            NonNull::new_unchecked(p)
        }
    }

    /// Creates a `Layout` from this type's metadata.
    fn layout(metadata: Self::Metadata) -> Layout;
}

impl<T: Metadata> Type for T {
    type Owned = T;

    #[inline(always)]
    fn make_fat_ptr(thin: *const (), _: Self::Metadata) -> *const Self {
        thin as *const Self
    }

    #[inline(always)]
    fn make_fat_ptr_mut(thin: *mut (), _: Self::Metadata) -> *mut Self {
        thin as *mut Self
    }

    /// The in-memory layout of sized types ignores type metadata.
    #[inline(always)]
    fn layout(_: Self::Metadata) -> Layout {
        Layout::new::<Self>()
    }
}

/// Pointer abstraction.
pub trait Ptr : Sized {
    unsafe fn get<'p, T: ?Sized + Load<Self>>(&'p self, metadata: T::Metadata) -> Ref<'p,T>;
    unsafe fn take<'p, T: Load<Self>>(self, metadata: T::Metadata) -> T;

    /// Deallocate the pointer.
    unsafe fn dealloc<T: ?Sized + Type>(self, metadata: T::Metadata);
}

/// Mutable pointer abstraction.
pub trait MutPtr : Ptr {
    unsafe fn get_mut<'p, T: ?Sized + Load<Self>>(&'p mut self, metadata: T::Metadata) -> RefMut<'p,T>;
}

/// The ability to allocate a new pointer.
pub trait Alloc<P: Ptr> {
    /// Allocates the pointer directly.
    unsafe fn alloc_raw<T: ?Sized + Type>(&mut self, metadata: T::Metadata, f: impl FnOnce(*mut T)) -> P;

    /// Allocates an `Own`.
    #[inline(always)]
    fn alloc<T: Type<Metadata=()>>(&mut self, value: T) -> Own<T, P> {
        unsafe {
            let p = self.alloc_raw((), |dst: *mut T| dst.write(value));
            Own::from_ptr(p, ())
        }
    }
}

impl<P: Ptr> Alloc<P> for ! {
    unsafe fn alloc_raw<T: ?Sized + Type>(&mut self, _: T::Metadata, _: impl FnOnce(*mut T)) -> P {
        match *self {}
    }
}

/// A type that can be loaded from a pointer.
pub trait Load<P> : Type {
}

/// Returned by `Ptr::get()`
pub enum Ref<'p, T: ?Sized + Type> {
    Borrowed(&'p T),
    Owned(<T as Type>::Owned),
}

/// Returned by `MutPtr::get_mut()`
pub enum RefMut<'p, T: ?Sized> {
    Borrowed(&'p T),
}

impl<'p, T: ?Sized + Type> ops::Deref for Ref<'p, T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        match self {
            Ref::Borrowed(r) => r,
            Ref::Owned(owned) => owned.borrow(),
        }
    }
}

impl<'p, T: ?Sized + Type> ops::Deref for RefMut<'p, T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        match self {
            RefMut::Borrowed(r) => r,
        }
    }
}


#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
